\section{Simulator Implementation}
% \quickwordcount{03.3_software}

\subsection*{Programming}
SpinWalk is a command line tool, developed entirely in C++ to ensure efficient resource usage and high performance in computationally intensive tasks and memory management. The project leverages CUDA technology for parallelization of computations. Although it significantly increases computation time, if necessary due to the absence of a GPU, the computation can be configured to run entirely on the CPU. Additionally, the simulator utilizes the Boost and HDF5 libraries, both of which are open source and compatible with widely used platforms. Parallelization on the CPU utilizes the Thread Building Blocks (TBB) library, which has been part of the C++ standard since C++17. This makes the project highly portable across different operating systems, enabling it to run in diverse environments. During execution, spins are distributed across GPU (or CPU) cores to undergo the diffusion process while also experiencing the simulated effects of a certain MRI sequence.


\subsection*{Framework Overview}
A detailed overview of SpinWalk, along with practical examples and a detailed documentation, are available on the SpinWalk GitHub repository. This section provides a concise introduction to the key concepts. The initialization of the simulation is specified through one or multiple text-based configuration files using the INI structure and syntax. Each configuration file represents an individual simulation and is passed as an argument to the simulator. The configuration file includes all the parameters required to define the simulation and can be adjusted by the user. These parameters encompass sequence definition, properties of the substrates such as relaxation times T1 and T2, input/output (I/O) files, and general settings. If multiple configurations (e.g., to assess the impact of TE) and several GPUs are available, such as in HPC clusters, each configuration can be assigned to a separate GPU or be executed sequentially on a single GPU.

\paragraph{\textbf{Sequence:}} Users have the possibility to configure RF pulses, TE, repetition time (TR), and gradients (across three axes) within the simulator. The simulator accommodates multiple RF pulses per TR, each with its own unique flip angle, phase, and onset. Moreover, multi-echo acquisition is supported. Custom gradient shapes for each axis can be generated from provided samples. Dephasing can be achieved using either gradients or an ideal dephasing mechanism (i.e., manually distributing phase). To establish steady-state conditions, users can specify the number of preparation pulses and define a certain phase-cycling. The dwell time for the RF pulse corresponds to a single diffusion time step. Accordingly, an RF waveform is applied as a sequence of hard pulses, occurring instantaneously and separated by intervals equal to one diffusion time step.

\paragraph{\textbf{I/O files:}} All input and output files are structured using the Hierarchical Data Format 5 (HDF5), renowned for its versatility and efficiency in data storage. It can be easily read and written in widely-used programming languages such as MATLAB and Python. The only required input file is the so-called "phantom" (VAN, cylinders, etc.), defining substrate boundaries and corresponding off-resonance maps if desired for inclusion in simulation. Multiple phantom files can be specified in one configuration file, allowing for identical sequence simulations across all. Optionally, users can provide initial magnetization and spin placement through additional input files. Otherwise, spins at equilibrium (i.e., \(M0_{xyz} = [0,0,1] \)) will be randomly distributed among substrates. Simulations of each phantom file produce a single output file containing all relevant variables, such as spins' magnetization at TEs and trajectory of random walks. 

\paragraph{\textbf{Substrates:}} The geometry and domains of substrates are defined in a discrete voxel space, referred to in this work as a \textit{voxel mesh}, and are stored as a 3D array in the phantom file. This array consists of integer values, each corresponding to a specific substrate. Each substrate has its own relaxation parameters (\(T_1\) and \(T_2\)) and diffusivity, specified in the configuration file. The movement of a spin between substrates during a random walk is controlled by a probability matrix of size \(N \times N\), where \(N\) is the number of substrates. In this matrix, \(P_{ij}\) at the \(i^{th}\) row and \(j^{th}\) column represents the probability of permeation from substrate \(i\) to substrate \(j\). A value of \(P_{ij} = 0\) indicates an impermeable boundary. A fixed probability method for modeling permeability has also been previously utilized in a Monte Carlo simulation of skeletal muscle tissue structure (\cite{hall2017diffusion}). In this work, if a spin cannot move between substrates due to permeability restrictions, a new random step will be drawn in case otherwise a boundary would have been crossed with the next step. For very large time scales, local variations of diffusivity will ultimately lead to an accumulation of particles in areas with lower diffusion. This can be seen as a limitation of the simulation, which of course can never represent all features of the real world, but the effect of this might at least be directly investigated using SpinWalk by e.g. comparing uniform against spatially depended diffusion. Alongside the substrate voxel mesh, a 3D array of the off-resonance map with the same dimensions can be stored. This off-resonance map results from susceptibility differences between substrates, and its absolute value scales with the static magnetic field. For convenience, this map should be calculated for \(B_0 = 1\,T\) and will be internally scaled by the simulator.

\paragraph{\textbf{General settings:}} General simulation parameters, including the number of spins and the static field strength, can be specified. Also, different spatial boundary conditions are implemented: if a spin exits the region of space occupied by the substrate, it can either re-enter from the opposite side, creating a periodic simulation environment, or be reflected back to remain within the volume. None of these boundary conditions might fully reflect the reality but the presented framework allows for a straightforward comparison of their effects on the resulting signal.